// Code generated with github.com/pdk/crudgen DO NOT EDIT.

package {{ .PackageName }}

import (
	"database/sql"
	"time"

	"github.com/pdk/crudgen/crudlib"
)

// Insert will insert one {{ .Struct.Name }} instance as a row in table {{ .TableName }}.
func (r *{{.Struct.Name}}) Insert(db *sql.DB) error {
    return crudlib.InTransaction(db, func (tx *sql.Tx) error {
        return r.InsertTx(tx)
    })
}

// InsertTx will insert, given a transaction.
func (r *{{.Struct.Name}}) InsertTx(tx *sql.Tx) error {
    {{ range .Struct.CreateTimestampFields }}
    r.{{ .FieldName }} = time.Now(){{ end }}{{ range .Struct.UpdateTimestampFields }}
    r.{{ .FieldName }} = time.Now()
    {{ end }}
    err := crudlib.PreInsert(tx, r)
    if err != nil {
        return err
    }

    insertStatement := `{{ .Style.Rebind (.Struct.InsertStatement .TableName) }}`
    {{ if .Struct.HasAutoIncrColumn }}
    var newID int64
    err = tx.QueryRow(insertStatement, {{ .Struct.InsertBindVars }}).Scan(&newID)
    r.{{ .Struct.AutoIncrFieldName }} = newID;
    {{ else }}
    _, err = tx.Exec(insertStatment, {{ .Struct.InsertBindVars }})
    {{ end }}

    if err != nil {
        return err
    }

    return crudlib.PostInsert(tx, r)
}

// Update will update a row in table {{ .TableName }}.
func (r *{{ .Struct.Name }}) Update(db *sql.DB) (rowCount int64, err error) {
    err = crudlib.InTransaction(db, func (tx *sql.Tx) error {
        rowCount, err = r.UpdateTx(tx)
        return err
    })

    return rowCount, err
}

// UpdateTx will update a row, within a transaction.
func (r *{{ .Struct.Name }}) UpdateTx(tx *sql.Tx) (rowCount int64, err error) {
    {{ range .Struct.UpdateTimestampFields }}
    r.{{ .FieldName }} = time.Now()
    {{ end }}
    err = crudlib.PreUpdate(tx, r)
    if err != nil {
        return 0, err
    }

    updateStatement := `{{ .Style.Rebind (.Struct.UpdateStatement .TableName) }}`

    result, err := tx.Exec(updateStatement, {{ .Struct.UpdateBindVars }})

	if err != nil {
		return 0, err
	}

    rows, err := result.RowsAffected()
    if err != nil {
        return rows, err
    }

    return rows, crudlib.PostUpdate(tx, r)
}

// Delete will delete a row in table {{ .TableName }}.
func (r *{{ .Struct.Name }}) Delete(db *sql.DB) (rowCount int64, err error) {
    err = crudlib.InTransaction(db, func (tx *sql.Tx) error {
        rowCount, err = r.DeleteTx(tx)
        return err
    })

    return rowCount, err
}

// DeleteTx executes PreDelete, delete, and PostDelete within a transaction.
func (r *{{ .Struct.Name }}) DeleteTx(tx *sql.Tx) (rowCount int64, err error) {

    deleteStatement := `{{ .Style.Rebind (.Struct.DeleteStatement .TableName) }}`

    err = crudlib.PreDelete(tx, r)
    if err != nil {
        return 0, err
    }

    result, err := tx.Exec(deleteStatement, {{ .Struct.DeleteBindVars }})

	if err != nil {
		return 0, err
	}

	rows, err := result.RowsAffected()
    if err != nil {
        return rows, err
    }

    return rows, crudlib.PostDelete(tx, r)
}

// {{ .Select }} will select records from table {{ .TableName }} and return a slice of
// {{ .Struct.Name }}. The additionalClauses argument should be SQL to be
// appended to the "select ... from {{ .TableName }}" statement, using "?" for bind
// variables.  E.g. "where foo = ?". bindValues must be provided in the correct
// order to match bind placeholders in the additionalClauses.
func {{ .Select }}(db *sql.DB, additionalClauses string, bindValues ...interface{}) ([]{{ .Struct.Name }}, error) {

    selectStatement := `{{ .Struct.SelectStatement .TableName }}`

    if len(additionalClauses) > 0 {
        selectStatement += " " + additionalClauses
        selectStatement = crudlib.{{ .Style.ConstName }}.Rebind(selectStatement)
    }

    values := []{{ .Struct.Name }}{}

    rows, err := db.Query(selectStatement, bindValues...)
    if err != nil {
        return values, err
    }
    defer rows.Close()

    for rows.Next() {
        i := {{ .Struct.Name }}{}
        err := rows.Scan({{ .Struct.ScanVars "i" }})
        if err != nil {
            return values, err
        }
        values = append(values, i)
    }

    err = rows.Err()
    if err != nil {
        return values, err
    }

    return values, rows.Close()
}

// {{ .Select }}All does a Select with no additional conditions/clauses.
func {{ .Select }}All(db *sql.DB) ([]{{ .Struct.Name }}, error) {
    return {{ .Select }}(db, "")
}

// {{ .Select }}Row will select one record from table {{ .TableName }} and return a
// {{ .Struct.Name }}. The additionalClauses argument should be SQL to be
// appended to the "select ... from {{ .TableName }}" statement, using "?" for bind
// variables.  E.g. "where foo = ?". bindValues must be provided in the correct
// order to match bind placeholders in the additionalClauses.
// Returns sql.ErrNoRows if no rows found.
func {{ .Select }}Row(db *sql.DB, additionalClauses string, bindValues ...interface{}) ({{ .Struct.Name }}, error) {

    selectStatement := `{{ .Struct.SelectStatement .TableName }}`

    if len(additionalClauses) > 0 {
        selectStatement += " " + additionalClauses
        selectStatement = crudlib.{{ .Style.ConstName }}.Rebind(selectStatement)
    }

    i := {{ .Struct.Name }}{}

    err := db.QueryRow(selectStatement, bindValues...).Scan(
        {{ .Struct.ScanVars "i" }})

    return i, err
}
